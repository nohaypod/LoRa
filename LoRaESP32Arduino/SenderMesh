// node v1.1 2022, Dec, 11
// -*- mode: C++ -*-
// Example sketch showing how to create a simple addressed, routed reliable messaging client
// with the RHMesh class.
// It is designed to work with the other examples bridge
// Hint: you can simulate other network topologies by setting the 
// RH_TEST_NETWORK define in RHRouter.h

// Mesh has much greater memory requirements, and you may need to limit the
// max message length to prevent weird crashes
#define RH_MESH_MAX_MESSAGE_LEN 50

#include <RHMesh.h>
#include <RH_RF95.h>
#include <SPI.h>
#include <LoRa.h>//LoRa Long Range Low Power
#include <Wire.h>// biblioteca Wire,usada para a comunicação I2C
//OLED 
#include <Adafruit_SSD1306.h>//biblioteca para controlar displays OLED
#define SCREEN_HEIGHT 64//indica a altura do display em pixels
#define SCREEN_WIDTH 128//indica o tamanho da largura do display em pixels
Adafruit_SSD1306 display(SCREEN_WIDTH, SCREEN_HEIGHT, &Wire, -1);// inicialização e comunicação I2C do display instace
//Libraries for DHT22/11
#include <DHT.h>//biblioteca usada para interagir com sensores de temperatura e umidade da série DHT 
//#include <DHT_U.h>//Unified Sensor Driver 
#include <Adafruit_Sensor.h>
//Configuração dos pinos para comunicação LoRa

// In this small artifical network of 4 nodes,
#define BRIDGE_ADDRESS 1  // address of the bridge ( we send our data to, hopefully the bridge knows what to do with our data )
#define NODE_ADDRESS 3    // address of this node

// lilygo T3 v2.1.6
// lora SX1276/8
#define LLG_SCK 5
#define LLG_MISO 19
#define LLG_MOSI 27
#define LLG_CS  18
#define LLG_RST 23 //14voce
#define LLG_DI0 26
#define LLG_DI1 33
#define LLG_DI2 32
#define BAND 866E6
//define a banda de frequência do módulo LoRa
//433E6 for Asia
//866E6 for Europe
//915E6 for North America
DHT dht(DHTPIN, DHTTYPE);//instancia sensor dth
uint32_t delayMS;

//Configuração dos pinos para  sensores
#define DHTPIN 14//define o pino ao qual o sensor DHT está conectado
#define DHTTYPE    DHT22// define o modelo do sensor DHT
#define TEMPERATURE_PRECISION 9//define a precisão da medição de temperatura
#define SensorPin 35 // define o pino do sensor de chuva 
#define LDR 39// define o pino do sensor luminosidade
#define MQ1 34 //define o pino do sensor MQ7
//declaração das variáveis que serão usadas para armazenar os dados dos sensores

float tempdht;
float umdht;
float hic;
float chuva;
int luz;
float ldrVoltage;

//initilize packet counter
int readingID = 0;
String LoRaMessage = "";

#define LLG_LED_GRN 25

// oled
#define LLG_OLED_SDA 21
#define LLG_OLED_SCL 22

// tfcard
#define LLG_SD_CS   13
#define LLG_SD_MISO 2
#define LLG_SD_MOSI 15
#define LLG_SD_SCK  14

#define TXINTERVAL 3000  // delay between successive transmissions
unsigned long nextTxTime;

// Singleton instance of the radio driver
RH_RF95 rf95(LLG_CS, LLG_DI0); // slave select pin and interrupt pin, [heltec|ttgo] ESP32 Lora OLED with sx1276/8

// Class to manage message delivery and receipt, using the driver declared above
RHMesh manager(rf95, NODE_ADDRESS);

void initDHT()
{
  // Initialize DHT device.
  Serial.println(F("Inicializando o sensor DHT"));
  dht.begin();
  Serial.println(F("DHT sensor is OK!"));
}

void obterDHTleituras (){
  // Delay between measurements.
  //delay(delayMS);
  // Get temperature event and print its value.
  sensors_event_t event;
  //dht.temperature().getEvent(&event);
  umdht = dht.readHumidity();
  tempdht = dht.readTemperature();
  luz = analogRead(LDR);  // Read LDR sensor value
  
  ldrVoltage = luz * (5.0 / 1023.0);  // Convert to voltage
}
void obterleituras(){
  obterDHTleituras();
  delay(5000);
}

void exibirleituras(){
  
  display.clearDisplay();
  display.setTextSize(1);
  display.setCursor(0,0);
  display.print("Pacote:");
  display.setCursor(50,0);
  display.print(readingID);
  display.setCursor(0,10);
  display.print("Temperatura:");
  display.setCursor(75,10);
  display.print(tempdht);
  display.print("");
  display.drawCircle(105,10,1, WHITE);
  display.setCursor(110,10);
  display.print("C");
  display.setCursor(0,20);
  display.print("(RH)Umidade:");
  display.setCursor(75,20);
  display.print(umdht);
  display.setCursor(105,20);
  display.print("(%)");
  display.setCursor(0,30);
  display.print("LUZ");
  display.setCursor(20,30);
  display.print(":");
  display.setCursor(30,30);
  display.print(ldrVoltage);
  //display.setCursor(60,30);
  //display.print("LUX");
  display.display();
  
  Serial.print("Temperatura:");
  Serial.print(tempdht);
  Serial.print(" °C\tUmidade:");
  Serial.print(umdht);
  Serial.print(" %\tLDR:");
  Serial.print(luz);
  Serial.print("\tPacote: ");
  Serial.println(readingID);
  
  readingID++;
}


void setup() 
{
  Serial.begin(115200);
  Serial.print(F("initializing node "));
  Serial.print(NODE_ADDRESS);
  SPI.begin(LLG_SCK,LLG_MISO,LLG_MOSI,LLG_CS);
  if (!manager.init())
    {Serial.println(" init failed");} 
  else
    {Serial.println(" done");}  // Defaults after init are 434.0MHz, 0.05MHz AFC pull-in, modulation FSK_Rb2_4Fd36 

  rf95.setTxPower(10, false); // with false output is on PA_BOOST, power from 2 to 20 dBm, use this setting for high power demos/real usage
  //rf95.setTxPower(1, true); // true output is on RFO, power from 0 to 15 dBm, use this setting for low power demos ( does not work on lilygo lora32 )
  rf95.setFrequency(868.0);
  rf95.setCADTimeout(500);

  // long range configuration requires for on-air time
  boolean longRange = false;
  if (longRange) 
    {
    // custom configuration
    RH_RF95::ModemConfig modem_config = {
      0x78, // Reg 0x1D: BW=125kHz, Coding=4/8, Header=explicit
      0xC4, // Reg 0x1E: Spread=4096chips/symbol, CRC=enable
      0x08  // Reg 0x26: LowDataRate=On, Agc=Off.  0x0C is LowDataRate=ON, ACG=ON
      };
    rf95.setModemRegisters(&modem_config);
    }
  else
    {
    // Predefined configurations( bandwidth, coding rate, spread factor ):
    // Bw125Cr45Sf128     Bw = 125 kHz, Cr = 4/5, Sf = 128chips/symbol, CRC on. Default medium range
    // Bw500Cr45Sf128     Bw = 500 kHz, Cr = 4/5, Sf = 128chips/symbol, CRC on. Fast+short range
    // Bw31_25Cr48Sf512   Bw = 31.25 kHz, Cr = 4/8, Sf = 512chips/symbol, CRC on. Slow+long range
    // Bw125Cr48Sf4096    Bw = 125 kHz, Cr = 4/8, Sf = 4096chips/symbol, low data rate, CRC on. Slow+long range
    // Bw125Cr45Sf2048    Bw = 125 kHz, Cr = 4/5, Sf = 2048chips/symbol, CRC on. Slow+long range
    if (!rf95.setModemConfig(RH_RF95::Bw125Cr45Sf128))
      {Serial.println(F("set config failed"));}
    }
  Serial.println("RF95 ready");
  nextTxTime = millis();
}

uint8_t data[] = String(readingID) + " " + String(tempdht)+" "+String(umdht)+" "+String(luz);
// Dont put this on the stack:
uint8_t buf[RH_MESH_MAX_MESSAGE_LEN];
uint8_t res;

void loop()
{
  obterleituras(); 
  exibirleituras();
  // send message every TXINTERVAL millisecs
  if (millis() > nextTxTime)
    {
    nextTxTime += TXINTERVAL;
    Serial.print("Sending to bridge n.");
    Serial.print(BRIDGE_ADDRESS);
    Serial.print(" res=");
    
    // Send a message to a rf95_mesh_server
    // A route to the destination will be automatically discovered.
    res = manager.sendtoWait(data, sizeof(data), BRIDGE_ADDRESS);
    Serial.println(res);
    if (res == RH_ROUTER_ERROR_NONE)
      {
      // Data has been reliably delivered to the next node.
      // now we do... 
      }
    else
      {
      // Data not delivered to the next node.
      Serial.println("sendtoWait failed. Are the bridge/intermediate mesh nodes running?");
      }
    }
  
  // radio needs to stay always in receive mode ( to process/forward messages )
  uint8_t len = sizeof(buf);
  uint8_t from;
  if (manager.recvfromAck(buf, &len, &from))
    {
    Serial.print("message from node n.");
    Serial.print(from);
    Serial.print(": ");
    Serial.print((char*)buf);
    Serial.print(" rssi: ");
    Serial.println(rf95.lastRssi()); 
    }
}
